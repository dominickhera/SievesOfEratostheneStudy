# Sieves Of Eratosthene Execution Time Study
A experiement comparing the execution speeds of the same Sieves of Eratosthene Prime Number function in 5 different languages.


My experience writing the Sieves of Eratosthenes Prime Number algorithm in C was for the most part positive and relatively painless in creating a functional and correct output the results into a text file. I would most likely attribute that to the fact that I have the most experience and knowledge in C so as a result, I didn’t need to reference the provided materials as I did for the legacy languages in which I was significantly less familiar with. As such I worked on the C version first and used it as a reference for all the other versions in all the different languages besides it as C is a very standard and basic language.
  
My experience writing the Sieves of Eratosthenes Prime Number algorithm in Python was surprisingly frustrating despite Python being such a high level coding language compared to the other languages. I wouldn’t attribute this to my lack of knowledge but more to my confusion and frustration towards the way that python handles lists and for loops. Since the list of numbers that the program would be processing started at 2 instead of 0 or 1, it took me a while to realize that despite declaring the list to start at 2, it neglected to actually do that and proceeded to start at the index of 0. As such, while I was doing all the calculations, everything was off by an index of 2 or more as a result. Besides that frustration and confusion in regards to the list indexing, I would say that Python was the second easiest of the five languages to translate the algorithm over into.
  
My experience writing the Sieves of Eratosthenes Prime Number algorithm in Fortran was relatively simple and painless to translate over for the most part. I’m not surprised at the relative ease due to the fact that of the previous projects, I found Fortran to be the most simple and easy language to understand and write in. I found it relatively wonky and weird as to how Fortran handles the declaration of arrays. As a result, I had to create workarounds through various functions to create a dynamically sized array to hold all the numbers within the range of numbers. The only part of the algorithm that I ended up having issues with was dealing with the I/O of the file output when outputting the results of the algorithm into a text document.  I don’t fully understand the way that it works, so as a result the Fortran version of the algorithm refuses to overwrite an already existing file when one is already created. Besides that, the Fortran version seemed to have been relatively simple and like Python but without the confusion regarding array indexing.
  
My experience writing the Sieves of Eratosthenes Prime Number algorithm in Ada was similar to when I worked on the previous A2 project in Ada, as it was very weird how it handled arrays. As such I had to refer back to my code to remember how I dealt with integers in arrays as for some reason, I got stuck on something as simple as inserting integers into the array for some reason. After getting everything working though, it seems that Ada provided the most consistently low execution times across each test.
  
My experience writing the Sieves of Eratosthenes Prime Number algorithm in COBOL is minimal because I ran out of time to completely finish the algorithm as I had to refocus my efforts on exams and procrastination from sheer lack of time management.
  
For the most part there was relatively minimal difference between languages as to each incremental increase in the upper limit of the amount of numbers entered. All the languages experienced a minor increase in required execution time when increasing the amount of numbers except for Fortran which seemed to have a more exponential growth in execution time, boasting some of the lower numbers compared to other langurs for upper limits like 100 but once reading 1,000,000 , Fortran proceeded to take over 483 seconds or 8 minutes to actually cycle through all the numbers while the next largest comparison would be Python which had only a 1.39 second execution time for the same number. There was an actual point where I thought the program had actually hit an infinite loop but alas, it actually just took significantly longer than all the other languages to execute. As for which languages were the most efficient, it mostly comes down to C and Ada whereas C is able to output results at a much quicker rate for lower limits but starts to fall behind Ada when it comes down to the higher numbers like 100000, and 1000000. Ada seems to have been more consistent across the tests for its execution times even being able to complete 1000000 faster than 10000 which was relatively confusing and I made sure to run the test several more times to confirm my findings.
  
  
  # Execution Time Comparison
  
  | Upper Limit  | 100 | 1000  | 10000 | 100000  | 1000000 |
| ------------- | ------------- |------------- | ------------- |------------- | ------------- |
| C  | 0.000548 Seconds | 0.000866 Seconds | 0.003882 Seconds | 0.025503 Seconds |  0.181946 Seconds |
| Python  | 0.00446391105652 Seconds | 0.00739598274231 Seconds | 0.0297448635101 Seconds | 0.154181003571 Seconds | 1.39259195238 Seconds |
| Fortran  | 0.000000015 Seconds | 0.00400000019 Seconds | 0.0599999987 Seconds | 4.94400024 Seconds | 483.415985 Seconds |
| ADA  | 0.0161819 Seconds | 0.026514383 Seconds | 0.057219 Seconds | 0.074529133 Seconds | 0.03707855 Seconds |
